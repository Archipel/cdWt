/*
 * WAbstractArea.cpp
 *
 *  Created on: 25-nov.-2014
 *      Author: thomas
 */

#include <Wt/WAbstractArea>
#include "CDWObject.h"

namespace Wt {
  class CDWAbstractArea : public CDWObject{
  protected:
    CDWAbstractArea(WAbstractArea* object = 0): CDWObject(object) {}

    WAbstractArea* getObject() const {
      return static_cast<WAbstractArea*>(wobject);
    }

  public:

    /*! \brief Specifies that this area specifies a hole for another area.
     *
     * When set to \c true, this area will define an area that does not
     * provide interactivity. When it preceeds other, overlapping,
     * areas, it acts as if it cuts a hole in those areas.
     *
     * The default value is \c false.
     *
     * \sa isHole()
     */
    virtual void setHole(bool hole){
      getObject()->setHole(hole);
    }

    /*! \brief Returns whether this area specifies a hole.
     *
     * \sa setHole()
     */
    virtual bool isHole() const {
      return getObject()->isHole();
    }

    /*! \brief Sets a link.
     *
     * By setting a link, the area behaves like a WAnchor.
     *
     * By default, no destination link is set.
     *
     * \note Even when no destination link is set, in some circumstances,
     *       an identity URL ('#') will be linked to on the underlying HTML
     *       &lt;area&gt; element (see also setCursor()).
     */
    virtual void setLink(const WLink& link){
      getObject()->setLink(link);
    }

    /*! \brief Returns the link.
     *
     * \sa setLink()
     */
    virtual WLink link() const{
      return getObject()->link();
    }

    /*! \brief Sets the destination URL (<b>deprecated</b>).
     *
     * By setting a destination URL, the area behaves like a
     * WAnchor.
     *
     * By default, no destination URL is set (\p ref = "").
     *
     * This method should not be used when the area has been pointed to
     * a dynamically generated resource using setResource().
     *
     * \sa setResource()
     *
     * \note Even when no destination URL is set, in some circumstances,
     *       a identity URL ('#') will be set on the underlying HTML
     *       &lt;area&gt; element (see also setCursor()).
     *
     * \deprecated Use setLink() instead.
     */
    virtual void setRef(const char* ref){
      getObject()->setRef(ref);
    }

    /*! \brief Returns the the destination URL (<b>deprecated</b>).
     *
     * When the area refers to a resource, the current resource URL is
     * returned.
     *
     * \sa setRef(), WResource::url()
     *
     * \deprecated Use link() instead.
     */
    const char* ref() const{
      return getObject()->ref().c_str();
    }

    /*! \brief Sets a destination resource (<b>deprecated</b>).
     *
     * A resource specifies application-dependent content, which may be
     * generated by your application on demand.
     *
     * By setting a resource, the area behaves like a WAnchor that
     * links to the resource \p resource. The resource may be
     * cleared by passing \p resource = \c 0.
     *
     * The area does not assume ownership of the resource.
     *
     * \sa setRef()
     *
     * \deprecated Use setLink() instead.
     */
    virtual void setResource(WResource *resource){
      getObject()->setResource(resource);
    }

    /*! \brief Returns the destination resource (<b>deprecated</b>).
     *
     * Returns \c 0 if no resource has been set.
     *
     * \sa setResource()
     *
     \deprecated Use link() instead.
     */
    virtual WResource *resource() const{
      return getObject()->resource();
    }

    /*! \brief Specifies the location where the referred content should be
     *         displayed.
     *
     * This configures the location where referred content should be
     * displayed, that was specified using setRef() or setResource().
     *
     * By default, the reference is displayed in the application
     * (Wt::TargetSelf). When the destination is an HTML document, the
     * application is replaced with the new document. When the reference
     * is a document that cannot be displayed in the browser, it is
     * offered for download or opened using an external program,
     * depending on browser settings.
     *
     * By setting \p target to Wt::TargetNewWindow, the destination
     * is displayed in a new browser window or tab.
     *
     * \sa setRef(), setResource(), target()
     */
    virtual void setTarget(const AnchorTarget& target){
      getObject()->setTarget(target);
    }

    /*! \brief Returns the location where the referred content should be
     *         displayed.
     *
     * \sa setTarget()
     */
    virtual AnchorTarget target() const{
      return getObject()->target();
    }

    /*! \brief Sets an alternate text.
     *
     * The alternate text should provide a fallback for browsers that do
     * not display an image. If no sensible fallback text can be
     * provided, an empty text is preferred over nonsense.
     *
     * This should not be confused with toolTip() text, which provides
     * additional information that is displayed when the mouse hovers
     * over the area.
     *
     * The default alternate text is an empty text ("").
     *
     * \sa alternateText()
     */
    virtual void setAlternateText(const WString& text){
      getObject()->setAlternateText(text);
    }

    /*! \brief Returns the alternate text.
     *
     * \sa setAlternateText()
     */
    virtual const WString alternateText() const{
      return getObject()->alternateText();
    }

    /*! \brief Sets the tooltip.
     *
     * The tooltip is displayed when the cursor hovers over the area.
     */
    virtual void setToolTip(const WString& text){
      getObject()->setToolTip(text);
    }

    /*! \brief Returns the tooltip text.
     *
     * \sa setToolTip()
     */
    virtual WString toolTip() const{
      return getObject()->toolTip();
    }

    /*! \brief Defines a style class.
     *
     * \note Only few CSS declarations are known to affect the look of a
     *       image area, the most notable one being the 'cursor'. Other things
     *       will simply be ignored.
     */
    virtual void setStyleClass(const WString& styleClass){
      return getObject()->setStyleClass(styleClass);
    }
    virtual void setStyleClass(const char* styleClass){
      return getObject()->setStyleClass(styleClass);
    }

    /*! \brief Returns the style class.
     *
     * \sa setStyleClass()
     */
    virtual WString styleClass() const{
      return getObject()->styleClass();
    }

    /*! \brief Adds a style class.
     *
     * \note Only few CSS declarations are known to affect the look of a
     *       image area, the most notable one being the 'cursor'. Other things
     *       will simply be ignored.
     */
    virtual void addStyleClass(const WString& styleClass, bool force = false){
      getObject()->addStyleClass(styleClass, force);
    }

    /*! \brief Removes a style class.
     */
    virtual void removeStyleClass(const WString& styleClass, bool force = false){
      getObject()->removeStyleClass(styleClass, force);
    }

    /*! \brief Sets the cursor.
     *
     * This sets the mouse cursor that is shown when the mouse pointer
     * is over the area. Most browsers only support PointingHandCursor,
     * which is activated by a non-empty ref.
     *
     * \sa setRef()
     */
    virtual void setCursor(Cursor cursor){
      getObject()->setCursor(cursor);
    }

    /*! \brief Sets a custom cursor image URL.
     *
     * The URL should point to a .cur file. For optimal portability, make
     * sure that the .cur file is proparly constructed. A renamed .ico file
     * will not work on Internet Explorer.
     */
    virtual void setCursor(const char* cursorImage, Cursor fallback = ArrowCursor){
      getObject()->setCursor(cursorImage, fallback);
    }

    /*! \brief Returns the cursor.
     *
     * \sa setCursor()
     */
    virtual Cursor cursor() const{
      return getObject()->cursor();
    }

    virtual WImage* image() const{
      return getObject()->image();
    }

  public:
    /*! \brief Event signal emitted when a keyboard key is pushed down.
     *
     * The keyWentDown signal is the first signal emitted when a key is
     * pressed (before the keyPressed() signal). Unlike keyPressed()
     * however it is also emitted for modifier keys (such as "shift",
     * "control", ...) or keyboard navigation keys that do not have a
     * corresponding character.
     *
     * \sa keyPressed(), keyWentUp()
     */
    virtual EventSignal<WKeyEvent>& keyWentDown(){
      return getObject()->keyWentDown();
    }

    /*! \brief Event signal emitted when a "character" was entered.
     *
     * The keyPressed signal is emitted when a key is pressed, and a
     * character is entered. Unlike keyWentDown(), it is emitted only
     * for key presses that result in a character being entered, and
     * thus not for modifier keys or keyboard navigation keys.
     *
     * \sa keyWentDown()
     */
    virtual EventSignal<WKeyEvent>& keyPressed(){
      return getObject()->keyPressed();
    }

    /*! \brief Event signal emitted when a keyboard key is released.
     *
     * This is the counter-part of the keyWentDown() event. Every
     * key-down has its corresponding key-up.
     *
     * \sa keyWentDown()
     */
    virtual EventSignal<WKeyEvent>& keyWentUp(){
      return getObject()->keyWentUp();
    }

    /*! \brief Event signal emitted when enter was pressed.
     *
     * This signal is emitted when the Enter or Return key was pressed.
     *
     * \sa keyPressed(), Key_Enter
     */
    virtual EventSignal<>& enterPressed(){
      return getObject()->enterPressed();
    }

    /*! \brief Event signal emitted when escape was pressed.
     *
     * This signal is emitted when the Escape key was pressed.
     *
     * \sa keyPressed(), Key_Escape
     */
    virtual EventSignal<>& escapePressed(){
      return getObject()->escapePressed();
    }

    /*! \brief Event signal emitted when a mouse key was clicked on this
     *         widget.
     *
     * The event details contains information such as the \link
     * WMouseEvent::button button\endlink, optional \link
     * WMouseEvent::modifiers() keyboard modifiers\endlink, and mouse
     * coordinates relative to the \link WMouseEvent::widget()
     * widget\endlink, the window \link WMouseEvent::window()
     * window\endlink, or the \link WMouseEvent::document()
     * document\endlink.
     *
     * \note When JavaScript is disabled, the event details contain
     * invalid information.
     */
    virtual EventSignal<WMouseEvent>& clicked(){
      return getObject()->clicked();
    }

    /*! \brief Event signal emitted when a mouse key was double clicked
     *         on this widget.
     *
     * The event details contains information such as the \link
     * WMouseEvent::button button\endlink, optional \link
     * WMouseEvent::modifiers() keyboard modifiers\endlink, and mouse
     * coordinates relative to the \link WMouseEvent::widget()
     * widget\endlink, the window \link WMouseEvent::window()
     * window\endlink, or the \link WMouseEvent::document()
     * document\endlink.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& doubleClicked(){
      return getObject()->doubleClicked();
    }

    /*! \brief Event signal emitted when a mouse key was pushed down on this
     *         widget.
     *
     * The event details contains information such as the \link
     * WMouseEvent::button button\endlink, optional \link
     * WMouseEvent::modifiers() keyboard modifiers\endlink, and mouse
     * coordinates relative to the \link WMouseEvent::widget()
     * widget\endlink, the window \link WMouseEvent::window()
     * window\endlink, or the \link WMouseEvent::document()
     * document\endlink.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseWentDown(){
      return getObject()->mouseWentDown();
    }

    /*! \brief Event signal emitted when a mouse key was released on this
     *         widget.
     *
     * The event details contains information such as the \link
     * WMouseEvent::button button\endlink, optional \link
     * WMouseEvent::modifiers() keyboard modifiers\endlink, and mouse
     * coordinates relative to the \link WMouseEvent::widget()
     * widget\endlink, the window \link WMouseEvent::window()
     * window\endlink, or the \link WMouseEvent::document()
     * document\endlink.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseWentUp(){
      return getObject()->mouseWentUp();
    }

    /*! \brief Event signal emitted when the mouse went out of this widget.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseWentOut(){
      return getObject()->mouseWentOut();
    }

    /*! \brief Event signal emitted when the mouse entered this widget.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseWentOver(){
      return getObject()->mouseWentOver();
    }

    /*! \brief Event signal emitted when the mouse moved over this widget.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseMoved(){
      return getObject()->mouseMoved();
    }

    /*! \brief Event signal emitted when the mouse is dragged over this widget.
     *
     * The mouse event contains information on the button(s) currently
     * pressed. If multiple buttons are currently pressed, only the
     * button with smallest enum value is returned.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseDragged(){
      return getObject()->mouseDragged();
    }

    /*! \brief Event signal emitted when the mouse scroll wheel was used.
     *
     * The event details contains information such as the \link
     * WMouseEvent::wheelDelta() wheel delta\endlink, optional \link
     * WMouseEvent::modifiers() keyboard modifiers\endlink, and mouse
     * coordinates relative to the \link WMouseEvent::widget()
     * widget\endlink, the window \link WMouseEvent::window()
     * window\endlink, or the \link WMouseEvent::document()
     * document\endlink.
     *
     * \note When JavaScript is disabled, the signal will never fire.
     */
    virtual EventSignal<WMouseEvent>& mouseWheel(){
      return getObject()->mouseWheel();
    }
  };
}

